package main;
import java.util.ArrayList;

import enums.ErrorType;
import output.Error;
import output.Print;
import tokens.*;
import tokens.Number;

/**
 * The Lexer class.
 * Reads raw user input and converts to token objects
 * First stage of Compilation/Interpretation
 * 
 */

public class Lexer 
{	
	/** The current line number. */
	static int lineNumber = 1;
	
	/**
	 * Converts raw user input to a list of tokens readable by the parser
	 *
	 * @param raw the raw user input
	 * @return the list of tokens
	 */
	public static ArrayList<Token> lex(ArrayList<String> raw)
	{
		ArrayList<Token> tokens = new ArrayList<Token>(); 	//The list of all tokens generated by the lexer from raw user input
		lineNumber = 1;
		
		for(String line:raw)	//Loop through each line of user input
		{
			ArrayList<Token> tokensFromRaw = tokenize(line);	//Tokenize the line
			Print.print(lineNumber + ":\t" + tokensFromRaw);	//Output the line
			tokens.addAll(tokensFromRaw);	//Add the tokenized line to the current list of tokens
			lineNumber++;	//Increment line number
		}
		
		return tokens;	//Return the list of tokens
	}

	/**
	 * Converts a line of raw user input to a list of tokens
	 *
	 * @param line the line of user input
	 * @return the list of tokens
	 */
	private static ArrayList<Token> tokenize(String line) 
	{
		ArrayList<Token> lexedLine = new ArrayList<Token>();	//The list of all tokens generated from this raw line
		int beginIndex = 0;
		int endIndex = 0;
		
		while(endIndex+1 <= line.length())	//Scan the entire line
		{
			if(Character.isAlphabetic(line.charAt(beginIndex)))	//If the current read character is alphabetic
			{
				while(Character.isAlphabetic(line.charAt(endIndex)))	//Keep reading until all alphabetic characters have been consumed
				{
					endIndex++;	//Increment read position
					if(endIndex >= line.length())
					{
						//If reached the end of the line, stop reading input
						break;
					}
				}
				lexedLine.add(new Word(line.substring(beginIndex, endIndex))); //Add this token (Word) to the current token list  
				beginIndex = endIndex;	//Start reading from the new position
			}
			else if(Character.isDigit(line.charAt(beginIndex)))	//If the current read character is numeric
			{
				Boolean point = false;	//Used to track decimal points in user input (only one can exist in a valid number)
				while(Character.isDigit(line.charAt(endIndex)) || (line.charAt(endIndex) == '.'))	//Keep reading until all numeric characters have been consumed
				{
					if(line.charAt(endIndex) == '.')
					{
						if(point)
						{
							//Throw an error if a number with 2 or more decimal points are found
							Error.print("Unknown Character Found: \"" + '.' + "\" on line " + lineNumber + " at position " + beginIndex, ErrorType.Lex, true);
						}
						else
						{
							//The rest of this number is fractional
							point = true;
						}
					}
					
					endIndex++;	//Increment read position
					if(endIndex >= line.length())
					{
						//If reached the end of the line, stop reading input
						break;
					}
				}
				lexedLine.add(new Number(Double.parseDouble(line.substring(beginIndex, endIndex)))); //Add this token (Number) to the current token list
				beginIndex = endIndex;	//Start reading from the new position
			}
			else	//The current read character is a symbol
			{
				Token chr = match(line.charAt(beginIndex), beginIndex);	//Match the character with its token object
				if(chr != null)	//If the match returned a valid token object
				{
					lexedLine.add(chr); //Add this token object to the current token list  
				}
				
				//Increment the read position
				beginIndex++;	
				endIndex++;
			}
		}
		return lexedLine;	//Return the list of tokens generated for this line
	}
	
	/**
	 * Matches ASCII symbols to their corresponding token object.
	 *
	 * @param chr the character to match
	 * @param position the current read position
	 * @return the token object
	 */
	private static Token match(Character chr, int position)
	{
		switch(chr)		//Select based on the input character
		{
			case ' ':
			case '	':
				return null;	//Ignore spaces and tab characters
			case '+':
				return new Plus();
			case '-':
				return new Minus();
			case '(':
				return new OpenBracket();
			case ')':
				return new CloseBracket();
			case '{':
				return new OpenBrace();
			case '}':
				return new CloseBrace();
			case '*':
				return new Times();
			case '/':
				return new Divide();
			case ';':
				return new Semicolon();
			case '=':
				return new Equals();
			case '>':
				return new GreaterThan();
			case '<':
				return new LessThan();
			case ',':
				return new Comma();
			default:
				//If a character does not exist in this list, then throw a lex error
				Error.print("Unknown Character Found: \"" + chr + "\" on line " + lineNumber + " at position " + position, ErrorType.Lex, true);
				return null;
		}
	}
}
